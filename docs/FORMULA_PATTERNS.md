# Formula Patterns

Complete, copy-paste ready formula templates for common build systems. Each pattern includes detection rules, common variations, and troubleshooting guidance.

## Table of Contents

1. [Rust/Cargo Projects](#rustcargo-projects)
2. [Go Projects](#go-projects)
3. [Python Projects](#python-projects)
4. [Make Projects](#make-projects)
5. [CMake Projects](#cmake-projects)
6. [Pre-built Binaries](#pre-built-binaries)

---

## Rust/Cargo Projects

### When to Use This Pattern

**Detection Rules:**
- Repository contains `Cargo.toml` in root
- Project builds with `cargo build --release`
- Binaries output to `target/release/`
- May have multiple binaries defined in `Cargo.toml`

**Typical Projects:** CLI tools, system utilities, TUI applications

### Complete Formula Template

```ruby
class Projectname < Formula
  desc "Brief description of what this tool does"
  homepage "https://github.com/USERNAME/PROJECT"
  url "https://github.com/USERNAME/PROJECT/archive/refs/tags/vVERSION.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "MIT" # or "Apache-2.0", "GPL-3.0", etc.

  # Rust toolchain required for building
  depends_on "rust" => :build
  
  # Optional: if the project needs OpenSSL, pkg-config, etc.
  # depends_on "openssl@3"
  # depends_on "pkg-config" => :build

  def install
    # Build the project in release mode
    system "cargo", "install", "--locked",
                    "--root", prefix,
                    "--path", "."
    
    # Alternative for projects with multiple binaries:
    # system "cargo", "build", "--release", "--locked"
    # bin.install "target/release/binary-name"
    # bin.install "target/release/another-binary"
    
    # Install shell completions if available
    # Many Rust projects generate these at build time
    bash_completion.install "completions/project.bash" => "project"
    fish_completion.install "completions/project.fish"
    zsh_completion.install "completions/_project"
    
    # Install man pages if present
    # man1.install "doc/project.1"
  end

  test do
    # Test that the binary exists and runs
    assert_match "VERSION", shell_output("#{bin}/project --version")
    
    # Test basic functionality
    # output = shell_output("#{bin}/project --help")
    # assert_match "USAGE:", output
    
    # For more complex tests, create a test file
    # (testpath/"test.txt").write "test content"
    # system bin/"project", "process", testpath/"test.txt"
    # assert_predicate testpath/"output.txt", :exist?
  end
end
```

### Common Variations

**Multiple Binaries:**
```ruby
def install
  system "cargo", "build", "--release", "--locked"
  bin.install "target/release/main-binary"
  bin.install "target/release/helper-tool"
  bin.install "target/release/daemon"
end
```

**Generate Completions at Build Time:**
```ruby
def install
  system "cargo", "install", "--locked", "--root", prefix, "--path", "."
  
  # Generate completions using the built binary
  generate_completions_from_executable(bin/"project", "completions")
end
```

**With System Dependencies:**
```ruby
depends_on "rust" => :build
depends_on "pkg-config" => :build
depends_on "openssl@3"
depends_on "libgit2"

def install
  # Set environment variables for linking
  ENV["OPENSSL_DIR"] = Formula["openssl@3"].opt_prefix
  ENV["LIBGIT2_SYS_USE_PKG_CONFIG"] = "1"
  
  system "cargo", "install", "--locked", "--root", prefix, "--path", "."
end
```

### Typical Dependencies

- `rust` (required for building)
- `pkg-config` (if linking to system libraries)
- `openssl@3` (common for network tools)
- `libgit2` (for git-related tools)
- `sqlite` (for database tools)

### Troubleshooting

**Problem:** Build fails with "linker error" or "could not find library"
**Solution:** Add the required system library as a dependency and set environment variables:
```ruby
depends_on "openssl@3"
ENV["OPENSSL_DIR"] = Formula["openssl@3"].opt_prefix
```

**Problem:** Completions not found after install
**Solution:** Check where cargo generates them. Common locations:
- `target/release/completions/`
- `completions/`
- Generated by running `project completions bash`

**Problem:** `cargo install` fails with workspace error
**Solution:** Use specific package name:
```ruby
system "cargo", "install", "--locked", "--root", prefix, "--path", "crates/main"
```

---

## Go Projects

### When to Use This Pattern

**Detection Rules:**
- Repository contains `go.mod` in root
- Project builds with `go build`
- Typically produces a single binary
- Binary name often matches repository name

**Typical Projects:** CLI tools, network utilities, servers

### Complete Formula Template

```ruby
class Projectname < Formula
  desc "Brief description of what this tool does"
  homepage "https://github.com/USERNAME/PROJECT"
  url "https://github.com/USERNAME/PROJECT/archive/refs/tags/vVERSION.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "MIT"

  # Go toolchain required for building
  depends_on "go" => :build

  def install
    # Set version info at build time (common pattern)
    ldflags = %W[
      -s -w
      -X main.version=#{version}
      -X main.commit=#{tap.user}
      -X main.date=#{time.iso8601}
    ]
    
    # Build the main binary
    system "go", "build", *std_go_args(ldflags: ldflags), "./cmd/project"
    
    # Alternative for simple projects:
    # system "go", "build", *std_go_args(ldflags: ldflags)
    
    # Alternative for specific output name:
    # system "go", "build", "-o", bin/"project", "-ldflags", ldflags.join(" ")
    
    # Install shell completions if available
    generate_completions_from_executable(bin/"project", "completion")
    
    # Install man pages if present
    # man1.install Dir["docs/man/*.1"]
  end

  test do
    # Test version output
    assert_match version.to_s, shell_output("#{bin}/project version")
    
    # Test help command
    output = shell_output("#{bin}/project --help")
    assert_match "Usage:", output
    
    # Test basic functionality
    # (testpath/"config.yaml").write <<~EOS
    #   setting: value
    # EOS
    # system bin/"project", "run", "--config", testpath/"config.yaml"
  end
end
```

### Common Variations

**Multiple Binaries in cmd/ Directory:**
```ruby
def install
  # Build each command
  system "go", "build", *std_go_args(ldflags: ldflags, output: bin/"project"), "./cmd/project"
  system "go", "build", *std_go_args(ldflags: ldflags, output: bin/"project-cli"), "./cmd/cli"
  system "go", "build", *std_go_args(ldflags: ldflags, output: bin/"project-server"), "./cmd/server"
end
```

**With CGO Dependencies:**
```ruby
depends_on "go" => :build
depends_on "pkg-config" => :build
depends_on "sqlite"

def install
  # Enable CGO
  ENV["CGO_ENABLED"] = "1"
  
  system "go", "build", *std_go_args(ldflags: ldflags)
end
```

**Install Additional Resources:**
```ruby
def install
  system "go", "build", *std_go_args(ldflags: ldflags)
  
  # Install configuration templates
  (etc/"project").install "config.example.yaml" => "config.yaml"
  
  # Install systemd service file
  (buildpath/"project.service").write <<~EOS
    [Unit]
    Description=Project Service
    
    [Service]
    ExecStart=#{opt_bin}/project
    
    [Install]
    WantedBy=multi-user.target
  EOS
  (etc/"systemd/system").install "project.service"
end
```

### Typical Dependencies

- `go` (required for building)
- `pkg-config` (if using CGO with system libraries)
- `sqlite` (for database functionality with CGO)

### Troubleshooting

**Problem:** Build fails with "cannot find package"
**Solution:** Ensure `go.mod` exists and run with proper module support:
```ruby
ENV["GO111MODULE"] = "on"
system "go", "build", *std_go_args(ldflags: ldflags)
```

**Problem:** Version string not embedded properly
**Solution:** Check the exact path to version variables:
```bash
# Find version variables in the code
grep -r "var version" .
# Common patterns: main.version, cmd.version, internal/version.Version
```

**Problem:** Binary runs but crashes with "not found" error
**Solution:** Missing CGO dependencies. Add and link:
```ruby
depends_on "sqlite"
ENV["CGO_ENABLED"] = "1"
```

---

## Python Projects

### When to Use This Pattern

**Detection Rules:**
- Repository contains `setup.py`, `pyproject.toml`, or `requirements.txt`
- Installable via `pip install`
- Provides command-line tools
- May have native extensions requiring compilation

**Typical Projects:** CLI tools, build systems, automation scripts

### Complete Formula Template

```ruby
class Projectname < Formula
  include Language::Python::Virtualenv

  desc "Brief description of what this tool does"
  homepage "https://github.com/USERNAME/PROJECT"
  url "https://files.pythonhosted.org/packages/source/p/project/project-VERSION.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "MIT"

  # Python 3 required
  depends_on "python@3.12"
  
  # If the project has native extensions that need building
  # depends_on "rust" => :build  # for cryptography, etc.
  # depends_on "cmake" => :build
  
  # System libraries that native extensions might need
  # depends_on "openssl@3"
  # depends_on "libffi"

  # Python dependencies (resources)
  # Get these with: curl -s https://pypi.org/pypi/PACKAGE/VERSION/json | jq -r '.urls[] | select(.packagetype=="sdist") | "\(.url)\n\(.digests.sha256)"'
  
  resource "click" do
    url "https://files.pythonhosted.org/packages/source/c/click/click-8.1.7.tar.gz"
    sha256 "ca9853ad459e787e2192211578cc907e7594e294c7ccc834310722b41b9ca6de"
  end

  resource "requests" do
    url "https://files.pythonhosted.org/packages/source/r/requests/requests-2.31.0.tar.gz"
    sha256 "942c5a758f98d7479f808c4c8d3d05f558458c0b73d4f51e8e0e1d5b5456987e"
  end

  # Add more resources as needed...

  def install
    # Create virtualenv in libexec
    virtualenv_install_with_resources
    
    # Install man pages if present
    # man1.install Dir["docs/*.1"]
    
    # Install shell completions if available
    # bash_completion.install "completions/project.bash" => "project"
    # fish_completion.install "completions/project.fish"
    # zsh_completion.install "completions/_project"
    
    # Generate completions from the tool itself (if supported)
    # generate_completions_from_executable(bin/"project", "completions")
  end

  test do
    # Test that the command exists and runs
    assert_match version.to_s, shell_output("#{bin}/project --version")
    
    # Test basic functionality
    # (testpath/"input.txt").write "test data"
    # system bin/"project", "process", testpath/"input.txt"
    # assert_predicate testpath/"output.txt", :exist?
    
    # Test Python import (for library projects)
    # system bin/"python3", "-c", "import project; print(project.__version__)"
  end
end
```

### Common Variations

**Manual Resource Installation (Fine-grained Control):**
```ruby
def install
  # Install each resource
  venv = virtualenv_create(libexec, "python3.12")
  
  # Install dependencies first
  resources.each do |r|
    venv.pip_install r
  end
  
  # Install the main package
  venv.pip_install_and_link buildpath
  
  # Or install from PyPI
  # venv.pip_install "project==#{version}"
end
```

**With Native Extensions:**
```ruby
depends_on "python@3.12"
depends_on "rust" => :build  # for cryptography, pyo3 modules
depends_on "openssl@3"

def install
  # Set environment for native builds
  ENV["OPENSSL_DIR"] = Formula["openssl@3"].opt_prefix
  
  virtualenv_install_with_resources
end
```

**Install Multiple Entry Points:**
```ruby
def install
  virtualenv_install_with_resources
  
  # If setup.py defines multiple console_scripts
  # They'll all be automatically linked into bin/
  # Verify with: ls -la libexec/bin/
end
```

**Install as Library with CLI:**
```ruby
def install
  virtualenv_install_with_resources
  
  # Add a wrapper script for Python library access
  (libexec/"bin").install_symlink bin/"project"
  
  # Add to PYTHONPATH for library imports
  site_packages = Language::Python.site_packages("python3.12")
  pth_contents = "import site; site.addsitedir('#{libexec/site_packages}')\n"
  (prefix/site_packages/"homebrew-project.pth").write pth_contents
end
```

### Typical Dependencies

- `python@3.12` (or current stable Python)
- `rust` (for cryptography, orjson, pydantic-core, etc.)
- `cmake` (for some native extensions)
- `openssl@3` (for cryptography)
- `libffi` (for cffi-based packages)

### Troubleshooting

**Problem:** Build fails with "No module named 'setuptools'"
**Solution:** Add setuptools as a resource:
```ruby
resource "setuptools" do
  url "https://files.pythonhosted.org/packages/source/s/setuptools/setuptools-69.0.3.tar.gz"
  sha256 "be1af57fc409f93647f2e8e4573a142ed38724b8cdd389706a867bb4efcf1e78"
end
```

**Problem:** Too many dependencies to list manually
**Solution:** Use `homebrew-pypi-poet` to generate resources:
```bash
pip install homebrew-pypi-poet
poet project > resources.txt
```

**Problem:** Import error at runtime
**Solution:** Check virtualenv was created correctly. Test with:
```ruby
test do
  system libexec/"bin/python", "-c", "import project"
end
```

**Problem:** Native extension build fails
**Solution:** Check for missing build dependencies and set environment:
```ruby
depends_on "rust" => :build
ENV["CARGO_HOME"] = buildpath/"cargo"
```

---

## Make Projects

### When to Use This Pattern

**Detection Rules:**
- Repository contains `Makefile` in root
- Traditional Unix build: `make && make install`
- May have `configure` script or `autogen.sh`
- Installs to `PREFIX` (defaults to `/usr/local`)

**Typical Projects:** C/C++ utilities, system tools, legacy projects

### Complete Formula Template

```ruby
class Projectname < Formula
  desc "Brief description of what this tool does"
  homepage "https://github.com/USERNAME/PROJECT"
  url "https://github.com/USERNAME/PROJECT/archive/refs/tags/vVERSION.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "GPL-3.0"

  # Common build dependencies
  depends_on "autoconf" => :build  # if using autogen.sh/configure.ac
  depends_on "automake" => :build
  depends_on "libtool" => :build
  depends_on "pkg-config" => :build
  
  # Common runtime dependencies
  # depends_on "openssl@3"
  # depends_on "readline"
  # depends_on "ncurses"
  # depends_on "zlib"

  def install
    # If project has configure script
    system "./configure", "--prefix=#{prefix}",
                          "--disable-debug",
                          "--disable-dependency-tracking"
    
    # If project has autogen.sh instead
    # system "./autogen.sh"
    # system "./configure", *std_configure_args
    
    # Build the project
    system "make"
    
    # Install (may need to override DESTDIR or PREFIX)
    system "make", "install"
    
    # Alternative if standard install doesn't work:
    # system "make", "install", "PREFIX=#{prefix}"
    # system "make", "install", "DESTDIR=#{prefix}"
    
    # Sometimes need to install manually:
    # bin.install "project"
    # man1.install "doc/project.1"
  end

  test do
    # Test the binary runs
    assert_match "version", shell_output("#{bin}/project --version")
    
    # Test basic functionality
    # system bin/"project", "--help"
    
    # Test with input file
    # (testpath/"test.txt").write "input"
    # system bin/"project", testpath/"test.txt"
  end
end
```

### Common Variations

**With Autotools (configure.ac):**
```ruby
depends_on "autoconf" => :build
depends_on "automake" => :build
depends_on "libtool" => :build

def install
  # Generate configure script
  system "./autogen.sh"
  
  # Or manually run autotools
  # system "autoreconf", "-fvi"
  
  system "./configure", *std_configure_args,
                        "--disable-silent-rules"
  system "make"
  system "make", "install"
end
```

**Custom Make Targets:**
```ruby
def install
  # Build specific targets
  system "make", "all", "docs"
  
  # Install with custom variables
  system "make", "install",
         "PREFIX=#{prefix}",
         "MANDIR=#{man}",
         "DESTDIR=/"
  
  # Some projects need explicit paths
  bin.install "bin/project"
  man1.install Dir["man/*.1"]
  (etc/"project").install "config.default" => "config"
end
```

**Parallel Build:**
```ruby
def install
  system "./configure", *std_configure_args
  
  # Use multiple cores for compilation
  system "make", "-j#{ENV.make_jobs}"
  system "make", "install"
end
```

**Patch Before Build:**
```ruby
def install
  # Fix hardcoded paths
  inreplace "Makefile", "/usr/local", prefix
  inreplace "src/config.h.in", "/etc/project", "#{etc}/project"
  
  system "./configure", *std_configure_args
  system "make"
  system "make", "install"
end
```

### Typical Dependencies

**Build-time:**
- `autoconf`, `automake`, `libtool` (for autotools)
- `pkg-config` (for finding libraries)
- `bison`, `flex` (for parsers/lexers)

**Runtime:**
- `openssl@3` (for TLS/crypto)
- `readline` (for interactive prompts)
- `ncurses` (for TUI)
- `zlib` (for compression)

### Troubleshooting

**Problem:** `configure: command not found`
**Solution:** Generate it with autotools:
```ruby
depends_on "autoconf" => :build
depends_on "automake" => :build
system "./autogen.sh"
```

**Problem:** Files installed to wrong locations
**Solution:** Override Make variables:
```ruby
system "make", "install",
       "PREFIX=#{prefix}",
       "BINDIR=#{bin}",
       "MANDIR=#{man}",
       "SYSCONFDIR=#{etc}"
```

**Problem:** `make install` tries to write to `/usr/local`
**Solution:** Use `DESTDIR`:
```ruby
system "make", "install", "DESTDIR=#{prefix}"
# May need to move files afterward
```

**Problem:** Parallel build fails randomly
**Solution:** Disable parallel builds:
```ruby
ENV.deparallelize
system "make"
```

---

## CMake Projects

### When to Use This Pattern

**Detection Rules:**
- Repository contains `CMakeLists.txt` in root
- Builds with `cmake && make && make install`
- Often C++ projects with complex build requirements
- Supports out-of-source builds

**Typical Projects:** C++ libraries, cross-platform applications, graphics tools

### Complete Formula Template

```ruby
class Projectname < Formula
  desc "Brief description of what this tool does"
  homepage "https://github.com/USERNAME/PROJECT"
  url "https://github.com/USERNAME/PROJECT/archive/refs/tags/vVERSION.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "Apache-2.0"

  # CMake required for building
  depends_on "cmake" => :build
  depends_on "pkg-config" => :build  # if project uses pkg-config
  
  # Common C++ dependencies
  # depends_on "boost"
  # depends_on "openssl@3"
  # depends_on "protobuf"
  # depends_on "grpc"

  def install
    # Create build directory (out-of-source build)
    mkdir "build" do
      # Configure with CMake
      system "cmake", "..",
             "-DCMAKE_BUILD_TYPE=Release",
             "-DBUILD_SHARED_LIBS=ON",
             "-DBUILD_TESTING=OFF",
             *std_cmake_args
      
      # Build
      system "make"
      
      # Install
      system "make", "install"
    end
    
    # Alternative: use cmake helper
    # system "cmake", "-S", ".", "-B", "build", *std_cmake_args
    # system "cmake", "--build", "build"
    # system "cmake", "--install", "build"
  end

  test do
    # Test the binary
    assert_match version.to_s, shell_output("#{bin}/project --version")
    
    # Test library linkage (for library projects)
    # (testpath/"test.cpp").write <<~EOS
    #   #include <project/project.h>
    #   int main() {
    #     project::init();
    #     return 0;
    #   }
    # EOS
    # system ENV.cxx, "test.cpp", "-L#{lib}", "-lproject", "-o", "test"
    # system "./test"
  end
end
```

### Common Variations

**Modern CMake (3.x syntax):**
```ruby
def install
  # Configure
  args = %W[
    -DCMAKE_BUILD_TYPE=Release
    -DBUILD_SHARED_LIBS=ON
    -DBUILD_TESTING=OFF
    -DPROJECT_ENABLE_FEATURE=ON
  ]
  
  system "cmake", "-S", ".", "-B", "build", *args, *std_cmake_args
  system "cmake", "--build", "build", "--parallel", ENV.make_jobs
  system "cmake", "--install", "build"
end
```

**With Dependencies in Non-standard Locations:**
```ruby
def install
  args = %W[
    -DCMAKE_BUILD_TYPE=Release
    -DOPENSSL_ROOT_DIR=#{Formula["openssl@3"].opt_prefix}
    -DBoost_INCLUDE_DIR=#{Formula["boost"].opt_include}
  ]
  
  system "cmake", "-S", ".", "-B", "build", *args, *std_cmake_args
  system "cmake", "--build", "build"
  system "cmake", "--install", "build"
end
```

**Install Multiple Targets:**
```ruby
def install
  system "cmake", "-S", ".", "-B", "build", *std_cmake_args
  system "cmake", "--build", "build"
  system "cmake", "--install", "build"
  
  # Install additional components
  system "cmake", "--install", "build", "--component", "development"
  
  # Or selectively install
  cd "build" do
    bin.install "bin/project"
    bin.install "bin/project-tool"
    lib.install Dir["lib/libproject.*"]
    include.install Dir["include/*"]
  end
end
```

**Disable Unwanted Components:**
```ruby
def install
  args = %W[
    -DCMAKE_BUILD_TYPE=Release
    -DBUILD_TESTING=OFF
    -DBUILD_EXAMPLES=OFF
    -DBUILD_DOCS=OFF
    -DENABLE_GUI=OFF
  ]
  
  system "cmake", "-S", ".", "-B", "build", *args, *std_cmake_args
  system "cmake", "--build", "build"
  system "cmake", "--install", "build"
end
```

### Typical Dependencies

**Build-time:**
- `cmake` (required)
- `pkg-config` (for finding libraries)
- `ninja` (optional, faster than make)

**Runtime:**
- `boost` (very common in C++ projects)
- `openssl@3` (for crypto)
- `protobuf` (for serialization)
- `grpc` (for RPC)
- `fmt` (for formatting)
- `spdlog` (for logging)

### Troubleshooting

**Problem:** CMake can't find a dependency
**Solution:** Set explicit paths:
```ruby
args = %W[
  -DOPENSSL_ROOT_DIR=#{Formula["openssl@3"].opt_prefix}
  -DBoost_ROOT=#{Formula["boost"].opt_prefix}
]
system "cmake", "-S", ".", "-B", "build", *args, *std_cmake_args
```

**Problem:** Build fails with "undefined reference"
**Solution:** Link order matters. Check CMakeLists.txt or add:
```ruby
ENV.append "LDFLAGS", "-L#{Formula["library"].opt_lib}"
```

**Problem:** Wrong library version found
**Solution:** Force CMake to use Homebrew libraries:
```ruby
ENV.append "CMAKE_PREFIX_PATH", HOMEBREW_PREFIX
```

**Problem:** Installation installs to wrong prefix
**Solution:** `std_cmake_args` should handle this, but verify:
```ruby
# Check what std_cmake_args expands to
args = std_cmake_args
# Should include: -DCMAKE_INSTALL_PREFIX=#{prefix}
```

**Problem:** Parallel build fails
**Solution:** Reduce parallelism or disable:
```ruby
system "cmake", "--build", "build", "--parallel", "1"
# or
ENV.deparallelize
```

---

## Pre-built Binaries

### When to Use This Pattern

**Detection Rules:**
- Project releases include pre-compiled binaries
- No source code compilation needed
- Tarball contains ready-to-run executables
- Often for proprietary software or complex builds

**Typical Projects:** Proprietary tools, large C++ projects, cross-compiled tools

### Complete Formula Template

```ruby
class Projectname < Formula
  desc "Brief description of what this tool does"
  homepage "https://example.com/project"
  url "https://example.com/releases/project-VERSION-linux-x86_64.tar.gz"
  sha256 "SHA256_HASH_HERE"
  license "MIT"  # or "Proprietary", "Commercial", etc.

  # Pre-built binaries are Linux x86_64 only
  depends_on :linux
  depends_on arch: :x86_64

  # Runtime dependencies (if binary needs specific libraries)
  # depends_on "openssl@3"
  # depends_on "zlib"

  def install
    # Install the main binary
    bin.install "project"
    
    # Install additional binaries if present
    # bin.install "project-cli"
    # bin.install "project-daemon"
    
    # Install libraries if present
    # lib.install Dir["lib/*"]
    
    # Install shared resources
    # (libexec/"project").install Dir["share/*"]
    # (etc/"project").install "config.default" => "config.yaml"
    
    # Install shell completions if present
    # bash_completion.install "completions/project.bash" => "project"
    # fish_completion.install "completions/project.fish"
    # zsh_completion.install "completions/_project"
    
    # Install man pages if present
    # man1.install Dir["man/*.1"]
    
    # Create wrapper script if needed (for setting LD_LIBRARY_PATH, etc.)
    # (bin/"project").write_env_script libexec/"bin/project-bin",
    #   LD_LIBRARY_PATH: "#{libexec}/lib:$LD_LIBRARY_PATH"
  end

  test do
    # Test the binary runs
    assert_match version.to_s, shell_output("#{bin}/project --version")
    
    # Basic functionality test
    # output = shell_output("#{bin}/project --help")
    # assert_match "Usage:", output
  end
end
```

### Common Variations

**With Wrapper Script for Environment:**
```ruby
def install
  # Install binary to libexec (not directly to bin)
  libexec.install Dir["*"]
  
  # Create wrapper that sets up environment
  (bin/"project").write_env_script libexec/"project",
    LD_LIBRARY_PATH: "#{libexec}/lib:$LD_LIBRARY_PATH",
    PROJECT_HOME:    libexec,
    PROJECT_CONFIG:  etc/"project"
end
```

**Multiple Architecture Support:**
```ruby
url "https://example.com/releases/project-VERSION-linux-x86_64.tar.gz",
    using: :nounzip
sha256 "SHA256_HASH_HERE"

# Different URLs for different architectures
on_arm do
  url "https://example.com/releases/project-VERSION-linux-aarch64.tar.gz"
  sha256 "DIFFERENT_SHA256_HERE"
end

def install
  bin.install "project"
end
```

**With Version-specific URLs:**
```ruby
# Use version in URL construction
url "https://releases.example.com/v#{version}/project-linux-x86_64.tar.gz"

# Or use string interpolation in the class
def self.url_for_version(ver)
  "https://example.com/releases/#{ver}/project-linux.tar.gz"
end

url url_for_version("VERSION")
```

**Extract and Patch:**
```ruby
def install
  # Install main binary
  bin.install "project"
  
  # Fix hardcoded paths in binary (use at your own risk!)
  # inreplace bin/"project" do |s|
  #   s.gsub! "/usr/local", prefix
  # end
  
  # Or use patchelf for dynamic libraries (requires patchelf)
  # depends_on "patchelf" => :build
  # system "patchelf", "--set-rpath", "#{lib}:#{Formula["openssl@3"].opt_lib}", bin/"project"
end
```

**Install with Sub-directory Structure:**
```ruby
def install
  # If tarball extracts to a versioned directory
  # cd "project-#{version}" do
  #   bin.install "bin/project"
  #   lib.install Dir["lib/*"]
  # end
  
  # Or if structure needs preserving
  libexec.install Dir["*"]
  bin.install_symlink libexec/"bin/project"
end
```

### Typical Dependencies

**Build-time:**
- Usually none (pre-built)
- `patchelf` (if modifying RPATH)

**Runtime:**
- System libraries the binary was linked against
- Check with: `ldd project` to see dependencies
- Common: `openssl@3`, `zlib`, `glibc`, `libstdc++`

### Troubleshooting

**Problem:** Binary fails with "cannot execute binary file"
**Solution:** Wrong architecture or corrupted download. Verify:
```bash
file /home/linuxbrew/.linuxbrew/bin/project
# Should show: ELF 64-bit LSB executable, x86-64
```

**Problem:** Binary fails with "error while loading shared libraries"
**Solution:** Missing runtime dependency or wrong RPATH. Check:
```bash
ldd /home/linuxbrew/.linuxbrew/bin/project
# Look for "not found" entries
```
Add missing libraries as dependencies:
```ruby
depends_on "openssl@3"
depends_on "zlib"
```

**Problem:** Binary runs but can't find data files
**Solution:** Use wrapper script to set environment:
```ruby
(bin/"project").write_env_script libexec/"project",
  PROJECT_HOME: libexec,
  PROJECT_DATA: libexec/"share"
```

**Problem:** "version `GLIBC_X.XX' not found"
**Solution:** Binary requires newer glibc than system has. Either:
1. Request older binary from upstream
2. Build from source instead
3. Document minimum system requirements

**Problem:** Binary is compressed or archived in unusual format
**Solution:** Handle extraction manually:
```ruby
def install
  # For .tar.xz
  system "tar", "xf", cached_download
  
  # For .zip
  system "unzip", cached_download
  
  # Then install
  bin.install "project"
end
```

---

## Quick Reference

| Build System | Detection | Key Command |
|-------------|-----------|-------------|
| **Rust** | `Cargo.toml` | `cargo install --locked --root #{prefix} --path .` |
| **Go** | `go.mod` | `go build *std_go_args(ldflags: ldflags)` |
| **Python** | `setup.py`, `pyproject.toml` | `virtualenv_install_with_resources` |
| **Make** | `Makefile` | `./configure *std_configure_args && make && make install` |
| **CMake** | `CMakeLists.txt` | `cmake -S . -B build *std_cmake_args && cmake --build build && cmake --install build` |
| **Binary** | Pre-compiled release | `bin.install "project"` |

## Getting Help

- Check the [Homebrew Formula Cookbook](https://docs.brew.sh/Formula-Cookbook)
- Search existing formulas: `brew search <name>` then `brew cat <formula>`
- Ask in Homebrew discussions: https://github.com/orgs/Homebrew/discussions

## Contributing

Found an issue or have a pattern to add? Contributions welcome!
